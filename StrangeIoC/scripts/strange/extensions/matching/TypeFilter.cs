//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:4.0.30319.18449
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------
using System;
using System.Collections.Generic;


namespace strange.extensions.matching
{
	public class TypeFilter : ITypeFilter
	{
		protected List<Type> allOfTypes;

		public List<Type> AllOfTypes
		{
			get
			{
				return allOfTypes; 
			}
		}
		
		protected List<Type> anyOfTypes;

		public List<Type> AnyOfTypes
		{
			get 
			{
				return anyOfTypes; 
			}
		}
		
		protected List<Type> noneOfTypes;

		public List<Type> NoneOfTypes
		{
			get
			{
				return noneOfTypes;
			}
		}
		
		protected string descriptor;

		public string Descriptor
		{
			get
			{
				return descriptor == null ? descriptor = CreateDescriptor() : descriptor;
			}
		}

		public TypeFilter(List<Type> allOf, List<Type> anyOf, List<Type> noneOf)
		{
			if (allOf == null || anyOf == null || noneOf == null)
				throw new ArgumentNullException("TypeFilter parameters can not be null");

			allOfTypes = allOf;
			anyOfTypes = anyOf;
			noneOfTypes = noneOf;
		}
		
		public bool Matches (object item)
		{
			Type itemType = item.GetType();

			int i = allOfTypes.Count;
			while (i-- != 0)
			{
				if (!itemType.IsAssignableFrom(allOfTypes[i]))
					return false;
			}
			
			i = noneOfTypes.Count;
			while (i-- != 0)
			{
				if (itemType.IsAssignableFrom(noneOfTypes[i]))
					return false;
			}

			if (anyOfTypes.Count == 0 && (allOfTypes.Count > 0 || noneOfTypes.Count > 0))
				return true;
			
			i = anyOfTypes.Count;
			while (i-- != 0)
			{
				if (itemType.IsAssignableFrom(anyOfTypes[i]))
					return true;
			}

			return false;
		}

		public string GetClassName(Type type)
		{
			return type.AssemblyQualifiedName;
			//TODO: The code below doesn't handle generic properly (code above does, but appears to be slower/bulkier)
			/*
			string className = type.Namespace;
			if (className != "") 
				className += ".";
			className += type.Name;
			if (type.IsGenericType)
			{
				Type genericType = type.GetGenericTypeDefinition();
				className += "-" + genericType.Namespace + genericType.Name;
			}
			return className;
			*/
		}

		public List<string> AlphabetiseCaseInsensitiveClassNames(List<Type> types)
		{
			List<string> allClassNames = new List<string>();

			foreach (Type type in types)
				allClassNames.Add(GetClassName(type));

			allClassNames.Sort(string.Compare);

			return allClassNames;
		}

		protected string CreateDescriptor()
		{
			List<string> allOfClassNames = AlphabetiseCaseInsensitiveClassNames(allOfTypes);
			List<string> anyOfClassNames = AlphabetiseCaseInsensitiveClassNames(anyOfTypes);
			List<string> noneOfClassNames = AlphabetiseCaseInsensitiveClassNames(noneOfTypes);
			return "all of: " + string.Join(", ", allOfClassNames.ToArray())
				+ ", any of: " + string.Join(", ", anyOfClassNames.ToArray())
				+ ", none of: " + string.Join(", ", noneOfClassNames.ToArray());
		}
	}
}

